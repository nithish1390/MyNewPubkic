import xml.etree.ElementTree as ET
from collections import defaultdict

BW_NS = {'pd': 'http://xmlns.tibco.com/bw/process/2003'}

def parse_bw_process(file_path):
    tree = ET.parse(file_path)
    root = tree.getroot()

    activities = {}
    transitions = []
    starter = root.find('pd:starter', BW_NS).attrib['name']
    end = root.findtext('pd:endName', default='End', namespaces=BW_NS)

    for act in root.findall('.//pd:activity', BW_NS):
        name = act.attrib['name']
        act_type = act.find('pd:type', BW_NS).text
        activities[name] = act_type

    for group in root.findall('.//pd:group', BW_NS):
        group_name = group.attrib['name']
        group_type = group.find('pd:type', BW_NS).text
        activities[group_name] = group_type
        for act in group.findall('.//pd:activity', BW_NS):
            name = act.attrib['name']
            act_type = act.find('pd:type', BW_NS).text
            activities[name] = act_type
        for t in group.findall('.//pd:transition', BW_NS):
            transitions.append({
                'from': t.find('pd:from', BW_NS).text,
                'to': t.find('pd:to', BW_NS).text,
                'condition': t.findtext('pd:conditionType', 'always', BW_NS),
                'xpath': t.findtext('pd:xpath', '', BW_NS)
            })

    for t in root.findall('pd:transition', BW_NS):
        transitions.append({
            'from': t.find('pd:from', BW_NS).text,
            'to': t.find('pd:to', BW_NS).text,
            'condition': t.findtext('pd:conditionType', 'always', BW_NS),
            'xpath': t.findtext('pd:xpath', '', BW_NS)
        })

    return starter, end, activities, transitions

def group_transitions(transitions):
    grouped = defaultdict(list)
    for t in transitions:
        grouped[t['from']].append(t)
    return grouped

def map_activity_to_camel_step(name, act_type):
    tag = name.replace(" ", "_")
    if "HTTPResponseActivity" in act_type:
        return f'<setBody><constant>FIN DEL PROCESAMIENTO</constant></setBody>'
    elif "FileWriteActivity" in act_type:
        return f'<to uri="file:output/?fileName={tag}.out" />'
    elif "NullActivity" in act_type:
        return f'<log message="Null activity: {name}" />'
    elif "LoopGroup" in act_type:
        return f'<log message="Loop start: {name}" />'
    else:
        return f'<log message="Activity: {name} ({act_type})" />'

def generate_route(start, end, activities, transitions):
    transition_map = group_transitions(transitions)
    visited = set()
    indent = "  "

    def dfs(node, depth=2):
        if node in visited:
            return []
        visited.add(node)
        steps = []

        # Add this activity
        if node in activities:
            steps.append(indent * depth + map_activity_to_camel_step(node, activities[node]))

        children = transition_map.get(node, [])
        if not children:
            return steps

        # Handle branching with <choice>
        if len(children) > 1 or any(c['condition'] != 'always' for c in children):
            steps.append(indent * depth + "<choice>")
            for t in children:
                to = t['to']
                cond = t['condition']
                step_block = dfs(to, depth + 2)
                if cond == 'xpath':
                    steps.append(indent * (depth + 1) + "<when>")
                    steps.append(indent * (depth + 2) + f"<xpath>{t['xpath']}</xpath>")
                    steps.extend(step_block)
                    steps.append(indent * (depth + 1) + "</when>")
                elif cond == 'otherwise':
                    steps.append(indent * (depth + 1) + "<otherwise>")
                    steps.extend(step_block)
                    steps.append(indent * (depth + 1) + "</otherwise>")
                elif cond == 'always':
                    steps.append(indent * (depth + 1) + "<when>")
                    steps.append(indent * (depth + 2) + "<constant>true</constant>")
                    steps.extend(step_block)
                    steps.append(indent * (depth + 1) + "</when>")
            steps.append(indent * depth + "</choice>")
        else:
            # Single unconditional child
            to = children[0]['to']
            steps.extend(dfs(to, depth))

        return steps

    route = ['<routes xmlns="http://camel.apache.org/schema/spring">']
    route.append(f'{indent}<route id="autoGeneratedRoute">')
    route.append(f'{indent*2}<from uri="direct:{start.replace(" ", "_")}" />')
    route.extend(dfs(start))
    route.append(f'{indent}</route>')
    route.append('</routes>')
    return "\n".join(route)

def convert_to_camel(file_path, output_path="camel_route.xml"):
    start, end, activities, transitions = parse_bw_process(file_path)
    xml = generate_route(start, end, activities, transitions)
    with open(output_path, "w") as f:
        f.write(xml)
    print(f"âœ… Camel route generated: {output_path}")

# Execute for provided BW process file
convert_to_camel("MainProcess.process.txt")
